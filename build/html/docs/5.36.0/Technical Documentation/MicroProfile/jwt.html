<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Eclipse MicroProfile JWT Authentication API :: Payara Documentation Preview</title>
    <meta name="generator" content="Antora 2.2.0">
    <link rel="stylesheet" href="../../../../_/css/site.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@alpha" />
    <meta name="docsearch:version" content="5.36.0" />
  </head>
  <body class="article">
  <header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../..">Payara Documentation Preview</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-item hide-for-print">
        Version: <div class="page-versions">
  <button class="version-menu-toggle single-version" title="Current version">5.36.0</button>
</div>

      </div>
      <div class="navbar-item hide-for-print">
            <div id="search-input-container">
    </div>
      </div>

      <div class="navbar-end">
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="https://www.payara.fish/products/downloads/">Download</a>
          </span>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary enterprise" href="../../../../../enterprise">Documentation for Payara Enterprise</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="docs" data-version="5.36.0">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-explore is-active" data-panel="explore">
  <div class="context">
    <span class="title">docs</span>
    <span class="version">5.36.0</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">docs</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../index.html">5.36.0</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../Overview.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../index.html">docs</a></li>
    <li><a href="jwt.html">Eclipse MicroProfile JWT Authentication API</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="file:///home/alanroth/Workspace/ondro-poc/docs/modules/ROOT/pages/Technical%20Documentation/MicroProfile/jwt.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<article class="doc">
<h1 class="page">Eclipse MicroProfile JWT Authentication API</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>Since <strong>4.1.2.181</strong>; <strong>5.181</strong>&nbsp;</em></p>
</div>
<div class="paragraph">
<p>Provided version of the API: {mpJwtSpecUrl}[MicroProfile Authentication API {mpJwtVersion}]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_background"><a class="anchor" href="#_background"></a>Background</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The JWT Authentication API was designed to provide application callers with the ability to authenticate themselves using a JWT token. A JWT token is essentially a string of JSON with fields for specifying the caller/user name and the groups the caller is in. To prevent tampering, the JSON token is cryptographically signed. Note that it&#8217;s only signed, not fully encrypted. This means that the caller/user name and the groups are in plain text, but because of the signature can&#8217;t be changed.</p>
</div>
<div class="paragraph">
<p>For a full overview of the API, review <a href="https://github.com/eclipse/microprofile-jwt-auth/releases">the documentation for the appropriate release.</a></p>
</div>
<div class="paragraph">
<p>A key goal of the specification was to not just provide authentication, but to provide a means of getting access to the JSON token that was used for authentication using CDI based injection, with an abundantly large and rich amount of possible conversions.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/eclipse/microprofile-jwt-auth/releases/tag/1.0">MicroProfile JWT Authentication 1.0</a> was released in MicroProfile 1.2</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Version 1.0 of the MicroProfile JWT Authentication specification does not define any means for preemptive authentication, that is, authenticating when the target resource (such as a JAX-RS end-point) is not protected / constrained by a security role. Practically this means that if a JWT token is sent alongside a request to a public / unchecked resource, MicroProfile JWT implementations will ignore it. This limitation will be addressed in a later version of the JWT specification.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_java_ee_security_and_jwt"><a class="anchor" href="#_java_ee_security_and_jwt"></a>Java EE Security and JWT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Payara Server Community and Payara Micro Community implement the JWT authentication mechanism as a normal Java EE Security (JSR 375) authentication mechanism. This specifically means that when MP JWT authentication is used on Payara Server or Payara Micro, there&#8217;s an <code>HttpAuthenticationMechanism</code> CDI bean enabled that can be intercepted or decorated using the standard CDI APIs. Likewise, there&#8217;s an <code>IdentityStore</code> CDI bean enabled, which can be intercepted or decorated too. By providing additional <code>IdentityStore</code> beans, an application can, if needed, augment the JWT identity store, for instance by providing extra roles.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_vending_tokens"><a class="anchor" href="#_vending_tokens"></a>Vending tokens</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A JWT token, like most API tokens, is typically vended from a website for use with the services provided by that site. For instance, from Google or Faceone can obtain such a token for usage with their respective APIs.</p>
</div>
<div class="paragraph">
<p>Though JWT tokens are more universal in format, they are still intended for use with a specific service (website / api). This is encoded in the <strong>mandatory</strong> <code>iss</code> ("issuer") field. The value of the field can be anything that the intended service can recognize (see below).</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "iss": "fish.payara.example",
    "jti": "a-123",
    "sub": "24400320",
    "aud": "s6BhdRkqt3",
    "upn": "test",
    "groups": [
        "architect",
        "master",
        "leader",
        "dev"
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A JWT also <strong>must</strong> be signed, and in the case of MicroProfile JWT this <strong>must</strong> be RSASSA-PKCS-v1_5 using the SHA-256 hash algorithm.</p>
</div>
<div class="paragraph">
<p>One way to do this signing is by first generating an SSH keypair as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Open Terminal</p>
</li>
<li>
<p>Generate the base key by entering: <code>openssl genrsa -out baseKey.pem</code></p>
</li>
<li>
<p>From the base key generate the PKCS#8 private key: <code>openssl pkcs8 -topk8 -inform PEM -in baseKey.pem -out privateKey.pem -nocrypt</code></p>
</li>
<li>
<p>And generate the public key: <code>openssl rsa -in baseKey.pem -pubout -outform PEM -out publicKey.pem</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Then put <code>privateKey.pem</code> on the root of the classpath (for instance, in a Maven project put it in <code>src/main/resources</code>) and use the following code to create the signed JSON token as a string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    public static String generateJWTString(String jsonResource) throws Exception {
        byte[] byteBuffer = new byte[16384];
        currentThread().getContextClassLoader()
                       .getResource(jsonResource)
                       .openStream()
                       .read(byteBuffer);

        JSONParser parser = new JSONParser(DEFAULT_PERMISSIVE_MODE);
        JSONObject jwtJson = (JSONObject) parser.parse(byteBuffer);

        long currentTimeInSecs = (System.currentTimeMillis() / 1000);
        long expirationTime = currentTimeInSecs + 1000;

        jwtJson.put(Claims.iat.name(), currentTimeInSecs);
        jwtJson.put(Claims.auth_time.name(), currentTimeInSecs);
        jwtJson.put(Claims.exp.name(), expirationTime);

        SignedJWT signedJWT = new SignedJWT(new JWSHeader
                                            .Builder(RS256)
                                            .keyID("/privateKey.pem")
                                            .type(JWT)
                                            .build(), parse(jwtJson));

        signedJWT.sign(new RSASSASigner(readPrivateKey("privateKey.pem")));

        return signedJWT.serialize();
    }

    public static PrivateKey readPrivateKey(String resourceName) throws Exception {
        byte[] byteBuffer = new byte[16384];
        int length = currentThread().getContextClassLoader()
                                    .getResource(resourceName)
                                    .openStream()
                                    .read(byteBuffer);

        String key = new String(byteBuffer, 0, length).replaceAll("-----BEGIN (.*)-----", "")
                                                      .replaceAll("-----END (.*)----", "")
                                                      .replaceAll("\r\n", "")
                                                      .replaceAll("\n", "")
                                                      .trim();

        return KeyFactory.getInstance("RSA")
                         .generatePrivate(new PKCS8EncodedKeySpec(Base64.getDecoder().decode(key)));
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code here assumes the location of the raw JSON file on the classpath being passed in, the private key on the root of the classpath and the result as a string. If other input/outputs are needed that should be easy to do using the above code as a starting point.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_accepting_tokens"><a class="anchor" href="#_accepting_tokens"></a>Accepting tokens</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_public_key_configuration"><a class="anchor" href="#_public_key_configuration"></a>Public Key configuration</h3>
<div class="paragraph">
<p>In order to validate the signature of a provided token is valid, an application
that uses JWT Authentication has to provide the public key to the MicroProfile JWT Authentication implementation either using the standard MicroProfile Config options or using the vendor-specific option.</p>
</div>
<div class="sect3">
<h4 id="_mp_jwt_verify_publickey"><a class="anchor" href="#_mp_jwt_verify_publickey"></a>mp.jwt.verify.publickey</h4>
<div class="paragraph">
<p>The <code>mp.jwt.verify.publickey</code> microprofile config property allows the Public Key text itself to be supplied as a string.</p>
</div>
<div class="paragraph">
<p><strong>For e.g :</strong>
<code>mp.jwt.verify.publickey=joer4fghieEM3UmZQcFRvNzM2fhMnJ6QV45ghRCdTQ1SnYwdXBkRVpjc54645jNJc65XltamJaUmtwZ1RSOEIxOWJfcl</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_mp_jwt_verify_publickey_location"><a class="anchor" href="#_mp_jwt_verify_publickey_location"></a>mp.jwt.verify.publickey.location</h4>
<div class="paragraph">
<p>The <code>mp.jwt.verify.publickey.location</code> microprofile config property allows for an external or internal location of Public Key to be specified. The value may be a relative path or a URL.</p>
</div>
<div class="paragraph">
<p><strong>For e.g :</strong>
<code>mp.jwt.verify.publickey=/META-INF/publicKey.pem</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_public_key_vendor_specific_configuration"><a class="anchor" href="#_public_key_vendor_specific_configuration"></a>public key vendor-specific configuration</h4>
<div class="paragraph">
<p>In Payara this is done by placing the public key such as generated above as <code>publicKey.pem</code> on the root of the application&#8217;s classpath. For example, when using a Maven project as <code>src/main/resources/publicKey.pem</code>.</p>
</div>
<div class="paragraph">
<p><strong>Note :</strong> Vendor-specific option for supplying the public key will always take precedence.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_issuer_configuration"><a class="anchor" href="#_issuer_configuration"></a>Issuer configuration</h3>
<div class="paragraph">
<p>Next to providing the public key, an application that uses JWT Authentication has to provide the issuer (corresponding to the <code>iss</code> field in the JSON token) it&#8217;s willing to accept.
Issuer can be provided to the MicroProfile JWT Authentication implementation either using the standard MicroProfile Config option or using the vendor-specific option.</p>
</div>
<div class="sect3">
<h4 id="_mp_jwt_verify_issuer"><a class="anchor" href="#_mp_jwt_verify_issuer"></a>mp.jwt.verify.issuer</h4>
<div class="paragraph">
<p>The <code>mp.jwt.verify.issuer</code> microprofile config property allows for the expected value of the iss claim to be specified.</p>
</div>
</div>
<div class="sect3">
<h4 id="_issuer_vendor_specific_configuration"><a class="anchor" href="#_issuer_vendor_specific_configuration"></a>issuer vendor-specific configuration</h4>
<div class="paragraph">
<p>In Payara this is done by placing a properties file named <code>payara-mp-jwt.properties</code> on the root of the application&#8217;s classpath. For example, when using a Maven project as <code>src/main/resources/payara-mp-jwt.properties</code>.
This properties file should contain the key <code>accepted.issuer</code> with as value the same value that of the <code>iss</code> field in the vended token, e.g. <code>fish.payara.example</code> as per the example JSON token shown above.</p>
</div>
<div class="paragraph">
<p><strong>Note :</strong> Vendor-specific option for supplying the issuer will always take precedence.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_namespaced_claims_configuration"><a class="anchor" href="#_namespaced_claims_configuration"></a>Namespaced claims configuration</h3>
<div class="paragraph">
<p><em>Since Payara Platform 5.184</em></p>
</div>
<div class="paragraph">
<p>Authentication services (like <a href="https://auth0.com/docs/scopes/current/custom-claims">auth0</a>, <a href="https://connect2id.com/products/server/docs/config/claims-mapping">connect2id</a>) offer the possibility to add custom claims to JWT tokens
but also enforce a namespaced format to avoid possible collisions with standard OpenID Connect claims.</p>
</div>
<div class="paragraph">
<p>In Payara, namespaced claims configuration is done by placing a properties file named <code>payara-mp-jwt.properties</code> on the root of the application&#8217;s classpath. For example, when using a Maven project as <code>src/main/resources/payara-mp-jwt.properties</code>.
This properties file should contain the boolean property <code>enable.namespace</code> and the optional property <code>custom.namespace</code>.</p>
</div>
<div class="sect3">
<h4 id="_enable_namespace"><a class="anchor" href="#_enable_namespace"></a><strong>enable.namespace</strong></h4>
<div class="paragraph">
<p>If this is true, the default <code><a href="https://payara.fish/mp-jwt/" class="bare">https://payara.fish/mp-jwt/</a></code> namespace will be used and the parser will look out for namespaced claims.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="paragraph">
<p>If following JSON is the token payload and <code>enable.namespace</code> property is true.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "https://payara.fish/mp-jwt/groups": ["admin", "read", "write"],
  "https://payara.fish/mp-jwt/upn": "test",
  "iss": "https://test.auth.com/",
  "sub": "5b2856bf8763ef356976dca3",
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the JSON Parser search for namespace prefixed claims, remove the namespace from claim name, allow the processing of the token as usual.</p>
</div>
</div>
<div class="sect3">
<h4 id="_custom_namespace"><a class="anchor" href="#_custom_namespace"></a><strong>custom.namespace</strong></h4>
<div class="paragraph">
<p>When the <code>custom.namespace</code> property is set, it will always take precedence over the default namespace and be used instead.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_disabling_type_claim_verification"><a class="anchor" href="#_disabling_type_claim_verification"></a>Disabling Type Claim Verification</h3>
<div class="paragraph">
<p><em>Since Payara Platform 5.2020.7</em></p>
</div>
<div class="paragraph">
<p>The MicroProfile JWT Authentication specification currently mandates that the type claim (<code>typ</code>) of any authorization token parsed by the container is present and is set to the <code>JWT</code> value. However, the current RFC document (<a href="https://tools.ietf.org/html/rfc7519">RFC 7519</a>) that defines the JWT standard states that this claim is <strong>optional</strong>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>5.1.  "typ" (Type) Header Parameter</p>
</div>
<div class="paragraph">
<p>The "typ" (type) Header Parameter defined by [JWS] and [JWE] is used by JWT applications to declare the media type [IANA.MediaTypes] of this complete JWT.  This is intended for use by the JWT application when values that are not JWTs could also be present in an application data structure that can contain a JWT object; the application can use this value to disambiguate among the different kinds of objects that might be present.</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Use of this Header Parameter is OPTIONAL.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>For this reason, some third-party token issuers may generate tokens that are not compatible with the MicroProfile JWT specification. The Payara Platform allows to set this verification off, so you can use the <code>disable.type.verification</code> custom property and set its value to <code>true</code> to this effect.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This property has to be defined in the <code>payara-mp-jwt.properties</code> configuration file described in the previous section.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Keep in mind that tokens which are missing their type claim and are propagated to other services running on other Eclipse MicroProfile runtimes might be rejected, as the specification mandates the inclusion of the claim.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_caching_the_public_key"><a class="anchor" href="#_caching_the_public_key"></a>Caching the Public Key</h3>
<div class="paragraph">
<p><em>Since Payara Platform 5.2021.1</em></p>
</div>
<div class="paragraph">
<p>By default, the public key retrieved by the <code>mp.jwt.verify.publickey.location</code> configuration property will be cached in memory for 5 minutes after being read from either a local file or a remote location. You can modify this <em>"time-to-live"</em> which determines how long the key stays cached in memory in the case you are dealing with long-lived keys, this is done by setting the <code>publicKey.cache.ttl</code> custom property.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This property has to be defined in the <code>payara-mp-jwt.properties</code> configuration file described in the previous section.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The value of the <code>publicKey.cache.ttl</code> property is defined in milliseconds, so keep this in mind when modifying the property
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_activating_jwt_authentication"><a class="anchor" href="#_activating_jwt_authentication"></a>Activating JWT Authentication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An application activates the JWT authentication mechanism and identity store by annotating a class in the application, for instance, the JAX-RS <code>Application</code> class, with <code>@LoginConfig(authMethod = "MP-JWT")</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_protecting_jax_rs_endpoints"><a class="anchor" href="#_protecting_jax_rs_endpoints"></a>Protecting JAX-RS endpoints</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MicroProfile JWT Authentication specifies that JAX-RS endpoints are to be secured by using the <code>javax.annotation.security.RolesAllowed</code> annotation. Note that while this is a general annotation, in Java EE it&#8217;s only EJB that interprets this. JAX-RS itself does not specify that this annotation should work on resource classes or methods and hence most implementations do not support it out of the box. Both Payara Server and Payara Micro do support it out of the box since <strong>4.1.2.181</strong> and <strong>5.181</strong>. This support holds for all types of authentication mechanisms, e.g. BASIC, and not just JWT.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
@Path("/resource")
@Produces(TEXT_PLAIN)
public class Resource {

    @Inject
    private Principal principal;

    @GET
    @Path("/protected")
    @RolesAllowed("architect")
    public String protectedResource() {
        return
            "This is a protected resource \n" +
            "web username: " + principal.getName() + "\n";
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_accessing_a_protected_endpoint"><a class="anchor" href="#_accessing_a_protected_endpoint"></a>Accessing a protected endpoint</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With the <code>generateJWTString()</code> method as presented above and the JWT token residing in a file called <code>jwt-token.json</code> on the classpath, a request to a JWT protected endpoint can be done as follows using the JAX-RS client API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String response =
            newClient()
                 .target(
                     URI.create(new URL(base, "resource/protected").toExternalForm()))
                 .request(TEXT_PLAIN)
                 .header(AUTHORIZATION, "Bearer " + generateJWTString("jwt-token.json"))
                 .get(String.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>With <code>base</code> being the context where the application is deployed, e.g. <code><a href="http://example.com/myapp" class="bare">http://example.com/myapp</a></code></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_switching_off_rolesallowed_support_in_jax_rs"><a class="anchor" href="#_switching_off_rolesallowed_support_in_jax_rs"></a>Switching off @RolesAllowed support in JAX-RS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The out-of-the-box support of <code>@RolesAllowed</code> for JAX-RS resources can be switched off by setting the <code>&lt;jaxrs-roles-allowed-enabled&gt;</code> tag in <code>WEB-INF/glassfish-web.xml</code> to <code>false</code>. For more information see the documentation for the <a href="#/documentation/payara-server/app-deployment/descriptor-elements.adoc#jaxrs-roles-allowed-enabled" class="page unresolved">jaxrs-roles-allowed-enabled</a> element.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_full_examples"><a class="anchor" href="#_full_examples"></a>Full examples</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Two full examples of using JWT authentication with a JAX-RS endpoint as well as a Servlet resource are provided here:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/javaee-samples/microprofile1.2-samples/tree/master/jwt-auth" class="bare">https://github.com/javaee-samples/microprofile1.2-samples/tree/master/jwt-auth</a></p>
</li>
</ul>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../../_/js/site.js"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script async src="../../../../_/js/vendor/docSearch.js"></script>
  </body>
</html>
